[{"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\pages\\AboutPage.tsx":"1","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\components\\DisplayFrostDates.tsx":"2","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\utils\\getCoordinates.ts":"3","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\index.tsx":"4","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\pages\\DashboardPage.tsx":"5","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\components\\DeviceLocation.tsx":"6","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\utils\\getUserElevation.ts":"7","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\components\\TextEntry.tsx":"8","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\utils\\getClosestStation.ts":"9","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\pages\\ResultsPage.tsx":"10","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\pages\\HomePage.tsx":"11"},{"size":3555,"mtime":1606761521352,"results":"12","hashOfConfig":"13"},{"size":2100,"mtime":1606760048417,"results":"14","hashOfConfig":"13"},{"size":3675,"mtime":1606754352402,"results":"15","hashOfConfig":"13"},{"size":441,"mtime":1602977784464,"results":"16","hashOfConfig":"13"},{"size":815,"mtime":1606763472002,"results":"17","hashOfConfig":"13"},{"size":2445,"mtime":1606754352350,"results":"18","hashOfConfig":"13"},{"size":808,"mtime":1606754352403,"results":"19","hashOfConfig":"13"},{"size":5008,"mtime":1606758490454,"results":"20","hashOfConfig":"13"},{"size":4122,"mtime":1606754352400,"results":"21","hashOfConfig":"13"},{"size":9367,"mtime":1606766931665,"results":"22","hashOfConfig":"13"},{"size":3134,"mtime":1606763780102,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"ks01mr",{"filePath":"27","messages":"28","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29","usedDeprecatedRules":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"41"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"35"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"50"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"41"},"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\pages\\AboutPage.tsx",[],[],"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\components\\DisplayFrostDates.tsx",["55"],"import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { IonCard, IonCardHeader, IonCardTitle, IonCardContent } from '@ionic/react';\r\nimport { FrostDatesBySeverity } from '../pages/ResultsPage';\r\nimport './DisplayFrostDates.css';\r\n\r\n//these codes are defined in NOAA's \"NORMAL_ANN_documentation.pdf\"\r\nconst checkApiReturn = (dayNum: any) => {\r\n  if(dayNum === '-4444') {  //-4444 is the code for year round frost risk\r\n    return 'Year-Round Frost Risk';\r\n  }\r\n  else if (dayNum === '-6666') { //-6666 is the code for undefined parameter/insufficent data\r\n    return 'Too Infrequent to Estimate';\r\n  }\r\n  else if ( dayNum === '-7777') { //-7777 is the code for non-zero value that rounds to zero\r\n    return 'Nearly Zero, Rounded Down.';\r\n  }\r\n  else { return dayNum.toString(); }\r\n};\r\n\r\nconst DisplayFrostDates: React.FC<FrostDatesBySeverity> = ({title, springFrost, fallFrost, frostFree}) => { \r\n  return (\r\n    <div>\r\n      <IonCard className='frost-card'>\r\n        <IonCardHeader className='frost-card-header'>\r\n          <IonCardTitle className='frost-card-title'>{title}</IonCardTitle>\r\n        </IonCardHeader>\r\n        <IonCardContent className='frost-card-content'>\r\n          <div className='frost-card-col'>\r\n            <div className='frost-card-col-header card-item'>Last Freeze</div>\r\n            <div className='frost-card-col-header card-item'>First Freeze</div>\r\n            <div className='frost-card-col-header card-item'>Growing Season</div>\r\n          </div>\r\n          <div className='frost-card-col'>\r\n            <div className='card-item'>{checkApiReturn(springFrost)}</div>\r\n            <div className='card-item'>{checkApiReturn(fallFrost)}</div>\r\n            <div className='card-item'>{checkApiReturn(frostFree)} days</div>\r\n          </div>\r\n        </IonCardContent>\r\n      </IonCard>\r\n    </div>\r\n  );\r\n};\r\n\r\nDisplayFrostDates.propTypes = {\r\n  title: PropTypes.string.isRequired,\r\n  springFrost: PropTypes.string.isRequired,\r\n  fallFrost: PropTypes.string.isRequired,\r\n  frostFree: PropTypes.string.isRequired\r\n};\r\n\r\nexport default DisplayFrostDates;",[],"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\utils\\getCoordinates.ts",[],"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\index.tsx",[],[],"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\pages\\DashboardPage.tsx",[],"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\components\\DeviceLocation.tsx",["56"],"import React, { useState } from 'react';\r\nimport { Geolocation, Geoposition } from '@ionic-native/geolocation/ngx';\r\nimport { IonButton, IonLoading, IonToast } from '@ionic/react';\r\nimport { getElevation } from '../utils/getUserElevation';\r\n\r\ninterface DeviceLocationProps {\r\n    onSubmit: (homeLat: number, homeLong: number, homeElev: number) => void;\r\n}\r\n\r\ninterface LocationError {\r\n    showError: boolean;\r\n    message?: string;\r\n}\r\n\r\nconst DeviceLocation: React.FC<DeviceLocationProps> = (props: DeviceLocationProps) => {\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<LocationError>({ showError: false });\r\n  const [position, setPosition] = useState<Geoposition>();\r\n  const geolocation = new Geolocation();\r\n\r\n  let lat: number | null = 0;\r\n  let long: number | null = 0;\r\n  let elev: number | null = 0;\r\n\r\n  const getLocation = async () => {\r\n    const options = {  //Device GPS location settings\r\n      enableHighAccuracy: true,\r\n      timeout: 8000\r\n    };\r\n\r\n    setLoading(true);\r\n\r\n    try { //use the device geolocation to get coordinates and possibly elevation\r\n      const position = await geolocation.getCurrentPosition(options);\r\n      setPosition(position);\r\n      setLoading(false);\r\n      setError({ showError: false });\r\n      lat = position.coords.latitude;\r\n      long = position.coords.longitude;\r\n      \r\n      // get user's elevation: if none from device, call the API\r\n      if(!position.coords.altitude) {\r\n        const apiElev = await getElevation(lat, long);\r\n        elev = apiElev;\r\n      }\r\n      else { //otherwise, use device's location\r\n        elev = position.coords.altitude;\r\n      }\r\n\r\n      props.onSubmit(lat, long, elev || 0);\r\n    } catch (e) {\r\n      let msg = e.message;\r\n      if(msg === 'Timeout expired') {msg += '. Make sure your device location service is enabled.';}\r\n      setError({ showError: true, message: msg });\r\n      setLoading(false);\r\n    }\r\n  };\r\n  return (\r\n    <div>\r\n      <IonLoading\r\n        isOpen={loading}\r\n        onDidDismiss={() => setLoading(false)}\r\n        message={'Getting Location...'}\r\n      />\r\n      <IonToast\r\n        isOpen={error.showError}\r\n        onDidDismiss={() => setError({ message: '', showError: false })}\r\n        message={error.message}\r\n        duration={5000}\r\n      />\r\n      <IonButton onClick={getLocation}>Use My Location</IonButton>\r\n    </div>\r\n  );\r\n};\r\nexport default DeviceLocation;\r\n",[],"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\utils\\getUserElevation.ts",[],"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\components\\TextEntry.tsx",["57"],"//Source code:\r\n//https://stackoverflow.com/questions/43872975/regular-expression-to-match-u-s-cities-allowing-certain-special-characters\r\nimport React, {useState} from 'react';\r\nimport './TextEntry.css';\r\nimport { IonInput, IonItem, IonButton, IonLoading, IonToast } from '@ionic/react';\r\nimport { Controller, useForm } from 'react-hook-form';\r\nimport {getCityStateCoordinates, getZipCoordinates, LocationData} from '../utils/getCoordinates';\r\n\r\ninterface TextEntryProps {\r\n  onSubmit: (homeLat: number, homeLong: number, homeElev: number) => void;\r\n}\r\ninterface DataError {\r\n  showError: boolean;\r\n  message?: string;\r\n}\r\n\r\nconst TextEntry: React.FC<TextEntryProps> = (props: TextEntryProps) => { \r\n  const { control, handleSubmit } = useForm();\r\n  const [loading, setLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<DataError>({ showError: false });\r\n  \r\n  //called when the text entry is determined to be a zip code\r\n  const getZipCodeData = async (zip: string) => {\r\n    setLoading(true);\r\n    const locationData: LocationData = await getZipCoordinates(zip); //gets the lat/long associated with this zipcode\r\n    if (locationData.hasError) {\r\n      console.log(locationData.errorMessage);\r\n      alert('No results found for your entry. Please check the validity of your five digit zip code.');\r\n    }\r\n    else if (locationData.latitude && locationData.longitude && locationData.elevation) { \r\n      props.onSubmit(locationData.latitude, locationData.longitude, locationData.elevation);\r\n    }\r\n    setLoading(false);\r\n  };\r\n\r\n  //called when the text entry is determined to be a city, state\r\n  const getCityStateData = async (cityName: string, stateCode: string) => {\r\n    setLoading(true);\r\n    const locationData: LocationData = await getCityStateCoordinates(cityName.toUpperCase(), stateCode.toUpperCase());\r\n        \r\n    if (locationData.hasError) {\r\n      console.log(locationData.errorMessage);\r\n      alert('No results found for your entry. Please check the validity of your city/state pair.');\r\n    }\r\n    else if (locationData.latitude && locationData.longitude && locationData.elevation) {\r\n      props.onSubmit(locationData.latitude, locationData.longitude, locationData.elevation);\r\n    }\r\n    setLoading(false);\r\n  };\r\n\r\n  //perform input validation on the user entered text and then determine if it is a zipcode or city, state\r\n  const getValid = (data: any) => {\r\n    let textEntry = data.text;\r\n    const regExp = /^[a-zA-Z',.\\s-]+,[ ]?[A-Za-z]{2}$/; //regex to check if format is comma separated city state pair\r\n    let commaCount = 0;\r\n    let buildCityName = '';\r\n    let buildStateCode = '';\r\n    //catch an empty string being passed\r\n    if(textEntry === undefined || textEntry === '') {\r\n      alert('Error, input appears to be blank');\r\n    }\r\n    else {  //find the comma index and count(there should be only 0 or 1 of them)\r\n      let idx = 0;\r\n      for(let i = 0; i < textEntry.length; i++) {\r\n        if(textEntry.charAt(i) === ',') { \r\n          idx = i;\r\n          commaCount+=1;\r\n        }\r\n      } //get the city name and set state variable.\r\n      for(let i = 0; i < idx; i++) { buildCityName += textEntry.charAt(i); }\r\n\r\n      //remove spaces after comma\r\n      for(let i = idx + 1; i < textEntry.length; i++) {\r\n        if(textEntry.charAt(i) === ' ') {\r\n          textEntry = textEntry.substring(0, i) + textEntry.substring(i + 1);\r\n          i--;\r\n        }\r\n        // add the character to the state code\r\n        else { buildStateCode += textEntry.charAt(i).toUpperCase(); }\r\n      }\r\n      //determine if the entry is a city/state pair\r\n      if(regExp.test(textEntry) && commaCount === 1) {\r\n        textEntry = textEntry.replace(/,/g, ',+\\'');\r\n        getCityStateData(buildCityName, buildStateCode);\r\n      }\r\n      //determine if entry is a valid zip code\r\n      else if(!(isNaN(parseInt(textEntry))) && textEntry.length === 5) { getZipCodeData(textEntry); }\r\n      //check for more than two characters after comma\r\n      else {alert('Entry is invalid, please try again. You must enter a five digit zip code or a city name followed by a comma and the two letter postal abbreviation of the state.');}\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"text-entry\">\r\n      <IonLoading\r\n        isOpen={loading}\r\n        onDidDismiss={() => setLoading(false)}\r\n        message={'Getting Data...'}\r\n      />\r\n      <IonToast\r\n        isOpen={true}\r\n        onDidDismiss={() => setError({ message: '', showError: false })}\r\n        message={error.message}\r\n        duration={3000} \r\n      />\r\n      <form onSubmit={handleSubmit(getValid)}>\r\n        <IonItem className=\"location-form\">\r\n          <Controller \r\n            as={<IonInput placeholder=\"Example: Salem, OR\" type=\"text\" />}\r\n            name=\"text\"\r\n            control={control}\r\n            onChangeName=\"onIonChange\"\r\n          />    \r\n        </IonItem>\r\n        <IonButton type=\"submit\">Submit</IonButton>\r\n      </form>\r\n    </div>\r\n  );\r\n};\r\nexport default TextEntry;\r\n","C:\\Users\\John\\Documents\\GitHub\\oga\\src\\utils\\getClosestStation.ts",["58"],"import stationsJSON from '../data/station_lat_long.json';\r\nimport frostJSON from '../data/frost_data.json';\r\n\r\nexport interface Station {\r\n  station: string;\r\n  latitude: number;\r\n  longitude: number;\r\n  elevation: number;\r\n  state: string;\r\n  city: string;\r\n  distance: number;\r\n}\r\n\r\nexport interface FrostData {\r\n  station: string;\r\n  fst_t24fp30: string;\r\n  fst_t28fp30: string;\r\n  fst_t32fp30: string;\r\n  lst_t24fp30: string;\r\n  lst_t28fp30: string;\r\n  lst_t32fp30: string;\r\n  gsl_t24fp30: string;\r\n  gsl_t28fp30: string;\r\n  gsl_t32fp30: string;\r\n  quality: string;\r\n}\r\n\r\nexport interface Coordinates {\r\n  lat: number;\r\n  long: number;\r\n}\r\n//create a stations list\r\nconst stations: Station[] = getWeatherStations();\r\n\r\n//get all weather stations from JSON file\r\nexport function getWeatherStations(): Station[] {\r\n  const stations: Station[] = stationsJSON.map( (data) => {\r\n    return {\r\n      station: data.id,\r\n      latitude: data.latitude,\r\n      longitude: data.longitude,\r\n      elevation: data.elevation,\r\n      state: data.state,\r\n      city: data.city,\r\n      distance: 999999\r\n    };\r\n  });\r\n  return stations;\r\n}\r\n\r\n//get all station frost data from JSON file\r\nexport function getFrostData(): FrostData[] {\r\n  const frostData: FrostData[] = frostJSON.map( (data) => {\r\n    return {\r\n      station: data.station,\r\n      fst_t28fp30: data['ann-tmin-prbfst-t28Fp30'],\r\n      fst_t24fp30: data['ann-tmin-prbfst-t24Fp30'],\r\n      fst_t32fp30: data['ann-tmin-prbfst-t32Fp30'],\r\n      lst_t24fp30: data['ann-tmin-prblst-t24Fp30'],\r\n      lst_t28fp30: data['ann-tmin-prblst-t28Fp30'],\r\n      lst_t32fp30: data['ann-tmin-prblst-t32Fp30'],\r\n      gsl_t24fp30: data['ann-tmin-prbgsl-t24Fp30'],\r\n      gsl_t28fp30: data['ann-tmin-prbgsl-t28Fp30'],\r\n      gsl_t32fp30: data['ann-tmin-prbgsl-t32Fp30'],\r\n      quality: data['quality']\r\n    };\r\n  });\r\n  return frostData;\r\n}\r\n\r\n// returns a list sorted by distance from the origin\r\nexport function getClosestStationList(origin: Coordinates): Station[] | null {\r\n  //get station distances\r\n  for (const station of stations) {\r\n    station.distance = getDistanceFromLatLongInKm(origin, {lat: station.latitude, long: station.longitude});\r\n  }\r\n  //sort stations by distance from user\r\n  stations.sort((a, b) => (a.distance > b.distance) ? 1 : -1);\r\n  return stations;\r\n}\r\n// uses Haversine formula, which gives the great-circle distance between two latitude-longitude pairs\r\n// will have some inaccuracy from assuming that earth is a perfect sphere\r\nexport const getClosestPoint = (origin: Coordinates, locations: Coordinates[]): Coordinates => {\r\n  let smallestDistance = Infinity;\r\n  let closestPosition: Coordinates = {\r\n    lat: 0,\r\n    long: 0\r\n  };\r\n  for (const location of locations) {\r\n    const distance: number = getDistanceFromLatLongInKm(origin, location);\r\n    if (distance < smallestDistance) {\r\n      smallestDistance = distance;\r\n      closestPosition = location;\r\n    }\r\n  }\r\n  return closestPosition;\r\n};\r\nconst convertDegreesToRadians = (degree: number) => {\r\n  return degree * (Math.PI / 180);\r\n}; \r\n// haversine formula: https://en.wikipedia.org/wiki/Haversine_formula\r\n// variable names a and c come from formula\r\n// source of code: https://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula/21623206#21623206\r\nexport const getDistanceFromLatLongInKm = (pointA: Coordinates, pointB: Coordinates) => {\r\n  const earthRadiusInKM = 6371;\r\n  const latitudeDifferenceInRadians: number = convertDegreesToRadians(pointB.lat - pointA.lat);\r\n  const longitudeDifferenceInRadians: number = convertDegreesToRadians(pointB.long - pointA.long); \r\n  const a: number = \r\n      Math.sin(latitudeDifferenceInRadians / 2) * Math.sin(latitudeDifferenceInRadians / 2) +\r\n      Math.cos(convertDegreesToRadians(pointA.lat)) * Math.cos(convertDegreesToRadians(pointB.lat)) * \r\n      Math.sin(longitudeDifferenceInRadians / 2) * Math.sin(longitudeDifferenceInRadians / 2); \r\n  const c: number = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); \r\n  const distance: number = earthRadiusInKM * c;\r\n  return distance;\r\n};\r\n",[],"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\pages\\ResultsPage.tsx",["59"],"C:\\Users\\John\\Documents\\GitHub\\oga\\src\\pages\\HomePage.tsx",[],{"ruleId":"60","severity":1,"message":"61","line":8,"column":33,"nodeType":"62","messageId":"63","endLine":8,"endColumn":36,"suggestions":"64"},{"ruleId":"65","severity":1,"message":"66","line":18,"column":10,"nodeType":"67","messageId":"68","endLine":18,"endColumn":18},{"ruleId":"60","severity":1,"message":"61","line":52,"column":27,"nodeType":"62","messageId":"63","endLine":52,"endColumn":30,"suggestions":"69"},{"ruleId":"70","severity":1,"message":"71","line":104,"column":43,"nodeType":"72","messageId":"73","endLine":104,"endColumn":88},{"ruleId":"65","severity":1,"message":"74","line":181,"column":27,"nodeType":"67","messageId":"68","endLine":181,"endColumn":28},"@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["75","76"],"@typescript-eslint/no-unused-vars","'position' is assigned a value but never used.","Identifier","unusedVar",["77","78"],"@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","ArrowFunctionExpression","missingReturnType","'e' is defined but never used.",{"messageId":"79","fix":"80","desc":"81"},{"messageId":"82","fix":"83","desc":"84"},{"messageId":"79","fix":"85","desc":"81"},{"messageId":"82","fix":"86","desc":"84"},"suggestUnknown",{"range":"87","text":"88"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"87","text":"89"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"90","text":"88"},{"range":"90","text":"89"},[350,353],"unknown","never",[2401,2404]]